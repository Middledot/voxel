"""
Python script to auto-generate the readers/writers for the MCBE protocol
(Au)tomatically (G)enerated (B)edrock (E)dition (P)rotocol

Will probably port to rust eventually
"""


import orjson, textwrap, abc

## Stuff to do
# 1. Make MsgBuffer work with the native datatypes (new ones that need to be implemented)
# 2. Structure of a packet file:
"""
use crate::... // ToBuffer, FromBuffer, MsgBuffer
<dependency1.outer>
<dependency2.inner>  // use super::..

pub struct <CamelCasePacket> {
    pub <orderedItem1>: type1;
    pub <orderedItem2>: type2;
    pub <orderedItem3>: type3;
}

impl PacketID for <CamelCasePacket> {
    const ID: u8 = <CamelCasePacket.ID>
}

impl FromBuffer for <CamelCasePacket> {
    fn from_buffer(buf: MsgBuffer) -> Self {
        let <orderedItem1>: <type1> = <type1{op=read}>  // uses <dependency1.outer>
        let <orderedItem2>: <type2> = <type2{op=read}>
        let <orderedItem3>: <type3> = <type3{op=from_buffer(&buf)}>  // uses <dependency2.inner> (i.e. other datatype)

        Self {
            <orderedItem1>,
            <orderedItem2>,
            <orderedItem3>,
        }
    }
}

impl ToBuffer for <CamelCasePacket> {
    fn to_buffer(&self) -> MsgBuffer {
        buf = MsgBuffer::new();
        <type1{op=write}>  // uses <dependency1.outer>
        <type2{op=write}>
        <type3{op=to_buffer}>  // uses <dependency2.inner> (i.e. other datatype)

        buf
    }
}

"""
# of course, we can manually write exceptions to this standard
# ALSO, enums will be separate files, need special checks for naming
# same with bitflags



class Property:
    def __init__(self, name, type):
        self.abs_deps = []
        self.deps = []

        self.name = name
        self.type = type  # replace with type objects (w/ dependencies and such)

    def attr(self):
        return "pub {0.name}: {0.type},".format(self)
    
    @abc.abstractmethod
    def to_buffer(self) -> str:
        pass
    
    @abc.abstractmethod
    def from_buffer(self) -> str:
        pass


class i32(Property):
    def __init__(self, name):
        super().__init__(name, "i32")

    def attr(self):
        return "pub {0.name}: {0.type},".format(self)

    def from_buffer(self):
        return "let {} = buf.read_i32_be_bytes();".format(self.name)

    def to_buffer(self):
        return "buf.write_i32_be_bytes(self.{});".format(self.name)


class GenericIOObject:
    def __init__(self, packet_id, name, props):
        self.abs_deps = ["use crate::raknet::objects::MsgBuffer;", "use crate::raknet::packets::{ToBuffer, FromBuffer, PacketID};"]
        self.deps = []

        self.packet_id = packet_id
        self.name: str = name

        self.props: list[Property] = props

    @property
    def name_camel_case(self):
        return ''.join(x.capitalize() for x in self.name.split('_'))

    @property
    def fmt_packet_id(self):
        return f"{hex(self.packet_id)};  // {self.packet_id}"

    @property
    def all_deps(self):
        deps = self.abs_deps
        for p in self.props:
            for ad in p.abs_deps:
                if ad not in deps:
                    deps.append(ad)
            for d in p.deps:
                if d not in deps:
                    deps.append(d)

        return '\n'.join(deps)

    def attrs(self):
        finalstr = ""
        for prop in self.props:
            finalstr += prop.attr() + "\n"
        
        return textwrap.indent(finalstr, "    ")

    def from_buffer(self):
        obj_ret = "Self {"
        finalstr = ""
        for prop in self.props:
            obj_ret += "\n    " + prop.name + ","
            finalstr += prop.from_buffer() + "\n"
        obj_ret += "\n}"
        finalstr += "\n" + obj_ret

        return textwrap.indent(finalstr, "        ")

    def to_buffer(self):
        finalstr = ""
        for prop in self.props:
            finalstr += prop.to_buffer() + "\n"

        return textwrap.indent(finalstr, "        ")

    def format(self):
        return (
            "/* Auto-generated by augbep */\n" \
            "{0.all_deps}\n" \
            "\n" \
            "struct {0.name_camel_case} {{\n" \
            "{1}" \
            "}}\n" \
            "\n" \
            "impl PacketID for {0.name_camel_case} {{\n" \
            "    const ID: u8 = {0.fmt_packet_id}\n" \
            "}}\n" \
            "\n"
            "impl FromBuffer for {0.name_camel_case} {{\n" \
            "    fn from_buffer(buf: &mut MsgBuffer) -> Self {{\n" \
            "{2}\n" \
            "    }}\n" \
            "}}\n" \
            "\n" \
            "impl ToBuffer for {0.name_camel_case} {{\n" \
            "    fn to_buffer(&self) -> MsgBuffer {{\n" \
            "        let mut buf = MsgBuffer::new();\n"
            "{3}" \
            "\n" \
            "        buf\n" \
            "    }}\n" \
            "}}\n" \
        ).format(self, self.attrs(), self.from_buffer(), self.to_buffer())  #, self.from_buffer(), self.to_buffer())

    @classmethod
    def from_data(cls, packet_id: int, name: str, blueprint: dict):
        props = []
        for param in blueprint:
            if param.get("type") == "i32":
                props.append(
                    i32(param["name"])
                )
                continue
            props.append(
                Property(**param)
            )
        return cls(packet_id, name, props)


class AugbepParser:
    def __init__(self):
        self.folder = "./v622/"
        self.packet_blueprints = {}
        self.packet_blueprint_mappings = {}

        self.map_packetid_to_packetname: dict[str, int] = {}

        self.genericio: list[GenericIOObject] = []

    def handle_native(key: str):
        match key:
            case "varint64":
                print("buf.{op}_i64_varint_bytes")
            case "zigzag32":
                print("buf.{op}_zigzag32")
            case "zigzag64":
                print("buf.{op}_zigzag64")
            # case "uuid":
            #     # TODO:
            # case "byterot":
            #     # TODO: what in tarnation is this?
            # case "bitflags":
            #     # TODO: 

    def parse(self):
        data: dict = orjson.loads(open("protocol.json", "rb").read())["types"]

        # Example thing
        # "packet_request_network_settings": [
        #     "container",
        #     [
        #         {
        #             "name": "client_protocol",
        #             "type": "i32"
        #         }
        #     ]
        # ],

        for k, v in data.items():
            k: str
            if k == "mcpe_packet":
                self.packet_mapping = v
                self.map_packetid_to_packetname = {v2: int(k2) for k2, v2 in v[1][0]["type"][1]["mappings"].items()}
                # print(self.map_packetid_to_packetname)
            elif isinstance(v, str):
                print(k)
            elif k.startswith("packet") and v[0] == "container":
                # print(k.replace("packet_", "", 1))
                # print(v)
                self.packet_blueprint_mappings[k.replace("packet_", "", 1)] = v[1]


        for name, blueprint in self.packet_blueprint_mappings.items():
            try:
                gen = GenericIOObject.from_data(
                    self.map_packetid_to_packetname[name],
                    name,
                    blueprint
                )
            except:
                pass
            else:
                self.genericio.append(gen)

        for obj in self.genericio:
            with open(self.folder + obj.name + ".rs", "w") as fp:
                try:
                    fp.write(obj.format())
                except:
                    pass

        with open(self.folder + "mod.rs", "w") as fp:
            for mod in self.genericio:
                fp.write("pub mod " + mod.name + ";\n")
            fp.write("\n")
            for mod in self.genericio:
                fp.write("pub use " + mod.name + "::" + mod.name_camel_case + ";\n")


        #     if isinstance(v, list) and v[0] not in lvl2types:
        #         lvl2types.append(v[0])

        # print(lvl2types)

AugbepParser().parse()

# obj = GenericIOObject.from_data(
#     193,
#     "request_network_settings",
#     [
#         {
#             "name": "client_protocol",
#             "type": "i32"
#         }
#     ]
# )

# print(obj.format())
